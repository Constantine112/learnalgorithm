# node总结

《node深入浅出》的总结



## 1 Node简介

### 1.1 Node的特点

Node自诞生利用V8引擎实现了利用javaScript语言搭建后台服务器的梦想，正式让js进军后端服务器。同时保留了JS的语言特性在后端的服务器上实现了事件驱动、作用域与原型链等特性

#### 1.1.1 异步IO

异步在前端中实现的非常普遍，其中的一个目的是为了减少页面的卡顿， **提高用户的体验感 **。可以利用前端的ajax作为例子说明。

当页面利用$.post()发送一个请求时，因为发送请求后到达的时间未知，所以这段等待的时间浏览器会做其他的事情，而当服务器response了，浏览器会停止当前动作转而执行post之后的回调函数，这个就是异步ajax，而异步IO也一样，请求读取文件，当读取完成，我们再执行读取文件的回调函数。下面就是一个代码和流程

```javascript
import fs from 'fs'
fs.readFile('/path', function (req, res) {
	console.log('读取文件完成')
})
console.log('发起读取文件')
```



![Alt text](https://qwe369399139.oss-cn-shenzhen.aliyuncs.com/node_md/1534063742612.jpg)

#### 1.1.2 事件与回调函数

node中利用了事件监听与回调函数的方式实现对请求的监听，而事件的编程方式**具有轻量级、松耦合、只关注事物点 **。但是这个就引发的另外一个问题，会不会导致很多请求的出现，无论css、html还是js都需要使用一个事件进行监听。而且因为监听的关系，代码的编写方式与执行顺序无关，这可能造成阅读上的障碍，流程也难以控制。

#### 1.1.3 单线程

Node保持了js的单线程特性，虽然原生的node无法实现单线程，将会在后续中讲述如何使用多线程。单线程的最大好处就是**不用像多线程那样处处在意状态的同步问题 **。但是单线程也有其弱点，**无法使用多核CPU、错误会引起程序退出、大量计算占用CPU导致无法调用异步IO **在前端中可以利用webWorker实现多核CPU的使用

#### 1.1.4 跨平台

node在底层中实现了两套的框架以实现对linux和windows两个系统中执行node

### 1.2 Node的应用场景

Node擅长的就是处理密集型I/O的利用，但是V8引擎的运算能力的优化，其实执行其它类型的应用也是很快的。CPU密集型应用主要给Node的挑战就是JS是单线程，可能会有大量的计算时间，导致后续请求无法快速响应。

使用node的倚重点可能会有点不一样

1. 前后端编程语言环境统一
2. Node带来的高性能I/O用于实时应用
3. 并行I/O使得使用者可以高效地利用分布式环境
4. 并行I/O，有效利用稳定接口提升Web渲染能力
5. 云计算平台提供Node支持
6. 游戏开发领域
7. 工具类应用

## 2 模块机制

在node开发出来之后，模块使用是JS的一大特色，就好像java的类文件一样。

可以利用CommomJS引入包，但是却有其弱点：

1. 没有模块系统
2. 标准库较少
3. 没有标准接口
4. 缺乏包管理系统

当然CommomJS的提出是为了弥补JS的缺陷，但是随着ES6的使用可以使用Import的方式实现包的引入，而且这个是以标准的方式记录下来。

当然node能以一种比较成熟的姿态出现离不开CommomJS规范的影响。关于各模块的引用，将在ES6中继续讲述。

Node引入模块，需要经历如下3个步骤：

1. 路径分析
2. 文件定位
3. 编译执行

在Node中模块分为两类：一类是Node提供的模块，称为核心模块：而是用户编写的模块，称为文件模块

### 2.1 核心模块

Node核心模块在编译成可执行文件的过程中被编译进了二进制文件，而在编译JS文件的时候，会将JS代码装换为C++里面的数组，在这个过程中，JS代码以字符串的形式保存早Node命名空间中且不可执行。

通常脚本语言的开发速度优于静态语言，但是其性能弱于静态语言，但是node在其中利用符合模式，在开发速度与性能间找到平衡点。

## 3 异步I/O

### 3.1 用户体验

因为在浏览器上是单线程的关系，JS的执行和UI的渲染是共用一个线程的，这个就造成了在js执行的时候UI渲染和相应是停滞的，而且脚本的单次执行时间不应该超过100ms。而采用异步请求，在下载资源期间，JS和UI的执行都不会处于停滞状态。

### 3.2 资源分配

计算机在发展过程中将组件进行了抽象，分为I/O设备和计算设备。

多线程的代价在于创建线程和执行期线程上下文切换的开销较大，而且在复杂的业务中，多线程编程经常面临锁、状态同步等问题。

单线程的执行能按照顺序思考的思维方式，但是一个略慢的任务会导致后续代码的阻塞。Node在两者时间给出方案，利用单线程远离死锁等问题，利用异步I/O让单线程上的资源分配更有效。

### 3.3 异步I/O与非阻塞I/O 

从实际效果来看，异步I/O与非阻塞I/O都达到了我们并行I/O的目的，但是从计算机内核来讲，确实两回事

#### 3.3.1 非阻塞I/O

阻塞I/O的特点是调用之后一定要等到系统内核层面完成所有操作后，调用才结束。以读取磁盘上的一个段文件为例，系统内核在完成磁盘寻道、读取数据、复制数据到内存中之后，这个调用才结束。所以阻塞I/O造成CPU等待I/O，浪费等待时间，CPU的处理能力不能得到充分利用。因为阻塞I/O在肚脐眼文件时会停止其他操作。

非阻塞I/O与阻塞I/O的差别为调用之后会立即返回。